{"version":3,"file":"my-lib.umd.js","sources":["../node_modules/src/enums/transformation-type.enum.ts","../node_modules/src/MetadataStorage.ts","../node_modules/src/storage.ts","../node_modules/src/decorators/type.decorator.ts","../node_modules/src/metadata/ValidationMetadata.ts","../node_modules/src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../node_modules/src/utils/get-global.util.ts","../node_modules/src/metadata/MetadataStorage.ts","../node_modules/src/validation/ValidationTypes.ts","../node_modules/src/container.ts","../node_modules/src/metadata/ConstraintMetadata.ts","../node_modules/src/register-decorator.ts","../node_modules/src/decorator/common/ValidateBy.ts","../node_modules/src/decorator/common/ValidateNested.ts","../node_modules/src/decorator/typechecker/IsString.ts","../src/index.ts"],"sourcesContent":["export enum TransformationType {\n  PLAIN_TO_CLASS,\n  CLASS_TO_PLAIN,\n  CLASS_TO_CLASS,\n}\n","import { TypeMetadata, ExposeMetadata, ExcludeMetadata, TransformMetadata } from './interfaces';\nimport { TransformationType } from './enums';\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n  private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n  private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n  private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n  private _ancestorsMap = new Map<Function, Function[]>();\n\n  // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n  addTypeMetadata(metadata: TypeMetadata): void {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addTransformMetadata(metadata: TransformMetadata): void {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  }\n\n  addExposeMetadata(metadata: ExposeMetadata): void {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  addExcludeMetadata(metadata: ExcludeMetadata): void {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  findTransformMetadatas(\n    target: Function,\n    propertyName: string,\n    transformationType: TransformationType\n  ): TransformMetadata[] {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return (\n          transformationType === TransformationType.CLASS_TO_CLASS ||\n          transformationType === TransformationType.PLAIN_TO_CLASS\n        );\n      }\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  }\n\n  findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  }\n\n  findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n    return this.getExposedMetadatas(target).find(metadata => {\n      return metadata.options && metadata.options.name === name;\n    });\n  }\n\n  findTypeMetadata(target: Function, propertyName: string): TypeMetadata {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  }\n\n  getStrategy(target: Function): 'excludeAll' | 'exposeAll' | 'none' {\n    const excludeMap = this._excludeMetadatas.get(target);\n    const exclude = excludeMap && excludeMap.get(undefined);\n    const exposeMap = this._exposeMetadatas.get(target);\n    const expose = exposeMap && exposeMap.get(undefined);\n    if ((exclude && expose) || (!exclude && !expose)) return 'none';\n    return exclude ? 'excludeAll' : 'exposeAll';\n  }\n\n  getExposedMetadatas(target: Function): ExposeMetadata[] {\n    return this.getMetadata(this._exposeMetadatas, target);\n  }\n\n  getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n    return this.getMetadata(this._excludeMetadatas, target);\n  }\n\n  getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExposedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n    return this.getExcludedMetadatas(target)\n      .filter(metadata => {\n        if (!metadata.options) return true;\n        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n        if (metadata.options.toClassOnly === true) {\n          return (\n            transformationType === TransformationType.CLASS_TO_CLASS ||\n            transformationType === TransformationType.PLAIN_TO_CLASS\n          );\n        }\n        if (metadata.options.toPlainOnly === true) {\n          return transformationType === TransformationType.CLASS_TO_PLAIN;\n        }\n\n        return true;\n      })\n      .map(metadata => metadata.propertyName);\n  }\n\n  clear(): void {\n    this._typeMetadatas.clear();\n    this._exposeMetadatas.clear();\n    this._excludeMetadatas.clear();\n    this._ancestorsMap.clear();\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private getMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n    }\n    const metadataFromAncestors: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(\n          meta => meta.propertyName !== undefined\n        );\n        metadataFromAncestors.push(...metadataFromAncestor);\n      }\n    }\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  }\n\n  private findMetadata<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T>>,\n    target: Function,\n    propertyName: string\n  ): T {\n    const metadataFromTargetMap = metadatas.get(target);\n    if (metadataFromTargetMap) {\n      const metadataFromTarget = metadataFromTargetMap.get(propertyName);\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        const ancestorResult = ancestorMetadataMap.get(propertyName);\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private findMetadatas<T extends { target: Function; propertyName: string }>(\n    metadatas: Map<Function, Map<string, T[]>>,\n    target: Function,\n    propertyName: string\n  ): T[] {\n    const metadataFromTargetMap = metadatas.get(target);\n    let metadataFromTarget: T[];\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n    const metadataFromAncestorsTarget: T[] = [];\n    for (const ancestor of this.getAncestors(target)) {\n      const ancestorMetadataMap = metadatas.get(ancestor);\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n    return metadataFromAncestorsTarget\n      .slice()\n      .reverse()\n      .concat((metadataFromTarget || []).slice().reverse());\n  }\n\n  private getAncestors(target: Function): Function[] {\n    if (!target) return [];\n    if (!this._ancestorsMap.has(target)) {\n      const ancestors: Function[] = [];\n      for (\n        let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n        typeof baseClass.prototype !== 'undefined';\n        baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)\n      ) {\n        ancestors.push(baseClass);\n      }\n      this._ancestorsMap.set(target, ancestors);\n    }\n    return this._ancestorsMap.get(target);\n  }\n}\n","import { MetadataStorage } from './MetadataStorage';\n\n/**\n * Default metadata storage is used as singleton and can be used to storage all metadatas.\n */\nexport const defaultMetadataStorage = new MetadataStorage();\n","import { defaultMetadataStorage } from '../storage';\nimport { TypeHelpOptions, TypeOptions } from '../interfaces';\n\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n *\n * Can be applied to properties only.\n */\nexport function Type(\n  typeFunction?: (type?: TypeHelpOptions) => Function,\n  options: TypeOptions = {}\n): PropertyDecorator {\n  return function (target: any, propertyName: string | Symbol): void {\n    const reflectedType = (Reflect as any).getMetadata('design:type', target, propertyName);\n    defaultMetadataStorage.addTypeMetadata({\n      target: target.constructor,\n      propertyName: propertyName as string,\n      reflectedType,\n      typeFunction,\n      options,\n    });\n  };\n}\n","import { ValidationMetadataArgs } from './ValidationMetadataArgs';\nimport { ValidationArguments } from '../validation/ValidationArguments';\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validation type.\n   */\n  type: string;\n\n  /**\n   * Target class to which this validation is applied.\n   */\n  target: Function | string;\n\n  /**\n   * Property of the object to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Constraint class that performs validation. Used only for custom validations.\n   */\n  constraintCls: Function;\n\n  /**\n   * Array of constraints of this validation.\n   */\n  constraints: any[];\n\n  /**\n   * Validation message to be shown in the case of error.\n   */\n  message: string | ((args: ValidationArguments) => string);\n\n  /**\n   * Validation groups used for this validation.\n   */\n  groups: string[] = [];\n\n  /**\n   * Indicates if validation must be performed always, no matter of validation groups used.\n   */\n  always?: boolean;\n\n  /**\n   * Specifies if validated value is an array and each of its item must be validated.\n   */\n  each: boolean = false;\n\n  /*\n   * A transient set of data passed through to the validation result for response mapping\n   */\n  context?: any = undefined;\n\n  /**\n   * Extra options specific to validation type.\n   */\n  validationTypeOptions: any;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(args: ValidationMetadataArgs) {\n    this.type = args.type;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.constraints = args.constraints;\n    this.constraintCls = args.constraintCls;\n    this.validationTypeOptions = args.validationTypeOptions;\n    if (args.validationOptions) {\n      this.message = args.validationOptions.message;\n      this.groups = args.validationOptions.groups;\n      this.always = args.validationOptions.always;\n      this.each = args.validationOptions.each;\n      this.context = args.validationOptions.context;\n    }\n  }\n}\n","import { ValidationSchema } from './ValidationSchema';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from '../metadata/ValidationMetadataArgs';\nimport { ValidationOptions } from '../decorator/ValidationOptions';\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n  transform(schema: ValidationSchema): ValidationMetadata[] {\n    const metadatas: ValidationMetadata[] = [];\n    Object.keys(schema.properties).forEach(property => {\n      schema.properties[property].forEach(validation => {\n        const validationOptions: ValidationOptions = {\n          message: validation.message,\n          groups: validation.groups,\n          always: validation.always,\n          each: validation.each,\n        };\n        const args: ValidationMetadataArgs = {\n          type: validation.type,\n          target: schema.name,\n          propertyName: property,\n          constraints: validation.constraints,\n          validationTypeOptions: validation.options,\n          validationOptions: validationOptions,\n        };\n        metadatas.push(new ValidationMetadata(args));\n      });\n    });\n    return metadatas;\n  }\n}\n","/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'window'.\n  if (typeof window !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    return window;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'self'.\n  if (typeof self !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    return self;\n  }\n}\n","import { ValidationMetadata } from './ValidationMetadata';\nimport { ConstraintMetadata } from './ConstraintMetadata';\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Private properties\n  // -------------------------------------------------------------------------\n\n  private validationMetadatas: ValidationMetadata[] = [];\n  private constraintMetadatas: ConstraintMetadata[] = [];\n\n  get hasValidationMetaData(): boolean {\n    return !!this.validationMetadatas.length;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema: ValidationSchema): void {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata: ValidationMetadata): void {\n    this.validationMetadatas.push(metadata);\n  }\n\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\n    this.constraintMetadatas.push(metadata);\n  }\n\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(\n    targetConstructor: Function,\n    targetSchema: string,\n    always: boolean,\n    strictGroups: boolean,\n    groups?: string[]\n  ): ValidationMetadata[] {\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n\n      // Use global default.\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    };\n\n    // get directly related to a target metadatas\n    const originalMetadatas = this.validationMetadatas.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // get metadatas for inherited classes\n    const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n        return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return (\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\n          originalMetadata.type === inheritedMetadata.type\n        );\n      });\n    });\n\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n    return this.constraintMetadatas.filter(metadata => metadata.target === target);\n  }\n}\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n  /* system */\n  static CUSTOM_VALIDATION = 'customValidation'; // done\n  static NESTED_VALIDATION = 'nestedValidation'; // done\n  static PROMISE_VALIDATION = 'promiseValidation'; // done\n  static CONDITIONAL_VALIDATION = 'conditionalValidation'; // done\n  static WHITELIST = 'whitelistValidation'; // done\n  static IS_DEFINED = 'isDefined'; // done\n\n  /**\n   * Checks if validation type is valid.\n   */\n  static isValid(type: string): boolean {\n    return (\n      type !== 'isValid' &&\n      type !== 'getMessage' &&\n      Object.keys(this)\n        .map(key => (this as any)[key])\n        .indexOf(type) !== -1\n    );\n  }\n}\n","/**\n * Container options.\n */\nexport interface UseContainerOptions {\n  /**\n   * If set to true, then default container will be used in the case if given container haven't returned anything.\n   */\n  fallback?: boolean;\n\n  /**\n   * If set to true, then default container will be used in the case if given container thrown an exception.\n   */\n  fallbackOnErrors?: boolean;\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T } = new (class {\n  private instances: { type: Function; object: any }[] = [];\n  get<T>(someClass: { new (...args: any[]): T }): T {\n    let instance = this.instances.find(instance => instance.type === someClass);\n    if (!instance) {\n      instance = { type: someClass, object: new someClass() };\n      this.instances.push(instance);\n    }\n\n    return instance.object;\n  }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions): void {\n  userContainer = iocContainer;\n  userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T } | Function): T {\n  if (userContainer) {\n    try {\n      const instance = userContainer.get(someClass);\n      if (instance) return instance;\n\n      if (!userContainerOptions || !userContainerOptions.fallback) return instance;\n    } catch (error) {\n      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;\n    }\n  }\n  return defaultContainer.get<T>(someClass);\n}\n","import { ValidatorConstraintInterface } from '../validation/ValidatorConstraintInterface';\nimport { getFromContainer } from '../container';\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Target class which performs validation.\n   */\n  target: Function;\n\n  /**\n   * Custom validation's name, that will be used as validation error type.\n   */\n  name: string;\n\n  /**\n   * Indicates if this validation is asynchronous or not.\n   */\n  async: boolean;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(target: Function, name?: string, async: boolean = false) {\n    this.target = target;\n    this.name = name;\n    this.async = async;\n  }\n\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Instance of the target custom validation class which performs validation.\n   */\n  get instance(): ValidatorConstraintInterface {\n    return getFromContainer<ValidatorConstraintInterface>(this.target);\n  }\n}\n","import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidatorConstraintInterface } from './validation/ValidatorConstraintInterface';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from './metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { ValidationArguments } from './validation/ValidationArguments';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\nimport { ValidationOptions } from './decorator/ValidationOptions';\n\nexport interface ValidationDecoratorOptions {\n  /**\n   * Target object to be validated.\n   */\n  target: Function;\n\n  /**\n   * Target object's property name to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Name of the validation that is being registered.\n   */\n  name?: string;\n\n  /**\n   * Indicates if this decorator will perform async validation.\n   */\n  async?: boolean;\n\n  /**\n   * Validator options.\n   */\n  options?: ValidationOptions;\n\n  /**\n   * Array of validation constraints.\n   */\n  constraints?: any[];\n\n  /**\n   * Validator that performs validation.\n   */\n  validator: ValidatorConstraintInterface | Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n  let constraintCls: Function;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n      validate(value: any, validationArguments?: ValidationArguments): Promise<boolean> | boolean {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments?: ValidationArguments): string {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs: ValidationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints,\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { registerDecorator } from '../../register-decorator';\nimport { ValidationArguments } from '../../validation/ValidationArguments';\nimport { ValidatorConstraintInterface } from '../../validation/ValidatorConstraintInterface';\n\nexport interface ValidateByOptions {\n  name: string;\n  constraints?: any[];\n  validator: ValidatorConstraintInterface | Function;\n  async?: boolean;\n}\n\nexport function buildMessage(\n  impl: (eachPrefix: string, args?: ValidationArguments) => string,\n  validationOptions?: ValidationOptions\n): (validationArguments?: ValidationArguments) => string {\n  return (validationArguments?: ValidationArguments): string => {\n    const eachPrefix = validationOptions && validationOptions.each ? 'each value in ' : '';\n    return impl(eachPrefix, validationArguments);\n  };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n  return function (object: object, propertyName: string): void {\n    registerDecorator({\n      name: options.name,\n      target: object.constructor,\n      propertyName: propertyName,\n      options: validationOptions,\n      constraints: options.constraints,\n      validator: options.validator,\n    });\n  };\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { ValidationMetadataArgs } from '../../metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from '../../validation/ValidationTypes';\nimport { ValidationMetadata } from '../../metadata/ValidationMetadata';\nimport { getMetadataStorage } from '../../metadata/MetadataStorage';\n\n/**\n * Objects / object arrays marked with this decorator will also be validated.\n */\nexport function ValidateNested(validationOptions?: ValidationOptions): PropertyDecorator {\n  const opts: ValidationOptions = { ...validationOptions };\n  const eachPrefix = opts.each ? 'each value in ' : '';\n  opts.message = opts.message || eachPrefix + 'nested property $property must be either object or array';\n\n  return function (object: object, propertyName: string): void {\n    const args: ValidationMetadataArgs = {\n      type: ValidationTypes.NESTED_VALIDATION,\n      target: object.constructor,\n      propertyName: propertyName,\n      validationOptions: opts,\n    };\n    getMetadataStorage().addValidationMetadata(new ValidationMetadata(args));\n  };\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { buildMessage, ValidateBy } from '../common/ValidateBy';\n\nexport const IS_STRING = 'isString';\n\n/**\n * Checks if a given value is a real string.\n */\nexport function isString(value: unknown): value is string {\n  return value instanceof String || typeof value === 'string';\n}\n\n/**\n * Checks if a given value is a real string.\n */\nexport function IsString(validationOptions?: ValidationOptions): PropertyDecorator {\n  return ValidateBy(\n    {\n      name: IS_STRING,\n      validator: {\n        validate: (value, args): boolean => isString(value),\n        defaultMessage: buildMessage(eachPrefix => eachPrefix + '$property must be a string', validationOptions),\n      },\n    },\n    validationOptions\n  );\n}\n","import { Type } from 'class-transformer';\nimport { IsString, ValidateNested } from 'class-validator';\n\nexport class MySubClassDto {\n    @IsString()\n    name: string;\n}\n\nexport class MyClassDto {\n    @IsString()\n    id: string;\n\n    @Type(() => MySubClassDto)\n    @ValidateNested()\n    child: MySubClassDto;\n}\n"],"names":["MetadataStorage"],"mappings":"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"}